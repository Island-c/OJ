# 打表可以更快的跑完程序、、。

## 题目：
    题目背景
    
    1742年6月7日哥德巴赫写信给当时的大数学家欧拉，正式提出了以下的猜想：任何一个大于9的奇数都可以表示成3个质数之和。质数是指除了1和本身之外没有其他约数的数，如2和11都是质数，而6不是质数，因为6除了约数1和6之外还有约数2和3。需要特别说明的是1不是质数。
    
    这就是哥德巴赫猜想。欧拉在回信中说，他相信这个猜想是正确的，但他不能证明。
    
    从此，这道数学难题引起了几乎所有数学家的注意。哥德巴赫猜想由此成为数学皇冠上一颗可望不可及的“明珠”。
    
    题目描述
    
    现在请你编一个程序验证哥德巴赫猜想。
    
    先给出一个奇数n，要求输出3个质数，这3个质数之和等于输入的奇数。
    
    输入输出格式
    
    输入格式：
    仅有一行，包含一个正奇数n，其中9< n < 20000
    
    输出格式：
    仅有一行，输出3个质数，这3个质数之和等于输入的奇数。相邻两个质数之间用一个空格隔开，最后一个质数后面没有空格。如果表示方法不唯一，请输出第一个质数最小的方案，如果第一个质数最小的方案不唯一，请输出第一个质数最小的同时，第二个质数最小的方案。
    
    输入输出样例
    
    输入样例#1：
    2009
    输出样例#1：
    3 3 2003
    
    
## 分析：
- 为了更快的跑完程序，先把小于n的所有质数打个表。。 
    - 判质数：
        - 1不是质数， 2 3 5 7…… 
        - 所以打表要从2开始打 。。
- 之后双重循环，从int向量（或者数组）中依次取出==两个数==
    - 取出两个数，第三个数可以通过减法得出，再判断一下它是不是质数就行了。 时间复杂度从O(n^3) 降为O(n^2)
    - 要判断第三个数是否为正数。
- 最坑的迭代器！
    - 迭代器只能使用一次！ 所以用双重for循环时， 最好还是中规中矩按照c语言的方法来用。。 QAQ 神坑

## 代码：

```cpp
#include<iostream>
#include<string>
#include<vector>

using namespace std;

int is_primer(int num){
	int sign=1;
	for(int i=2; i*i<=num ;++i){
		if(num%i==0) sign=0;
	}
	return sign;
}

int main(){
	int n=0;
	cin>>n;
	vector<int> v;
	
	int num=2;
	while(num<n){
		if(is_primer(num))  v.push_back(num);
		num++;
	}
	vector<int>::iterator beg1=v.begin(),end1=v.end();	
	int num1,num2,num3,sign=0;	
	for(beg1; beg1!=end1 ;++beg1){
	
		for(int i=0;i<v.size() ; ++i){
			if(sign ==1)	return 0;
			num1=*beg1; 
			num2=v[i];
			num3=n-num1-num2;
			if(is_primer(num3) && num3>0)	{
				cout<<num1<<" "<<num2<<" "<<num3<<endl;
				sign=1;
			}
		}

	 }
}
```

> 2017年5月12日13:30:40
    